# Project Rules for AI Agents

## Project Overview
This is a Next.js 15.5.9 application using React 19, TypeScript, and Tailwind CSS 4. The project follows modern React patterns with the App Router architecture.

## Tech Stack
- **Framework**: Next.js 15.5.9 (App Router)
- **React**: 19.1.0
- **TypeScript**: ^5
- **Styling**: Tailwind CSS 4
- **Linting/Formatting**: Biome 2.2.0
- **Build Tool**: Turbopack

## File and Folder Naming Conventions

### Critical Rule: Use kebab-case for ALL files and folders
- ✅ **Correct**: `user-profile.tsx`, `auth-service.ts`, `api-utils/`, `user-settings/`
- ❌ **Incorrect**: `UserProfile.tsx`, `authService.ts`, `apiUtils/`, `userSettings/`

### Specific Naming Rules
1. **Components**: `kebab-case.tsx` (e.g., `button-group.tsx`, `user-card.tsx`)
2. **Utilities**: `kebab-case.ts` (e.g., `format-date.ts`, `api-client.ts`)
3. **Hooks**: `use-kebab-case.ts` (e.g., `use-auth.ts`, `use-local-storage.ts`)
4. **Types**: `kebab-case.types.ts` (e.g., `user.types.ts`, `api-response.types.ts`)
5. **Constants**: `kebab-case.constants.ts` (e.g., `api-endpoints.constants.ts`)
6. **Folders**: `kebab-case/` (e.g., `components/`, `user-profile/`, `auth-provider/`)

### Next.js Special Files (Exceptions)
These Next.js convention files should remain as documented:
- `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`, `not-found.tsx`
- `route.ts` (for API routes)
- `middleware.ts`, `instrumentation.ts`

## React Best Practices & Modern Design Patterns

### 1. Component Architecture

#### Use Server Components by Default (Next.js 15)
```typescript
// ✅ Server Component (default)
export default async function UserProfile({ userId }: { userId: string }) {
  const user = await fetchUser(userId);
  return <div>{user.name}</div>;
}
```

#### Client Components Only When Needed
```typescript
// ✅ Client Component (when using hooks, events, browser APIs)
'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### 2. TypeScript Patterns

#### Prefer Interfaces for Props
```typescript
// ✅ Preferred
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

export function Button({ label, onClick, variant = 'primary' }: ButtonProps) {
  // ...
}
```

#### Use Type for Unions and Utilities
```typescript
// ✅ Good use of type
type Status = 'idle' | 'loading' | 'success' | 'error';
type UserWithoutPassword = Omit<User, 'password'>;
```

### 3. Modern React Patterns

#### Composition Over Props Drilling
```typescript
// ✅ Use composition and context
import { createContext, useContext } from 'react';

const ThemeContext = createContext<Theme | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;
}
```

#### Custom Hooks for Reusable Logic
```typescript
// ✅ Extract logic into custom hooks
// File: src/hooks/use-fetch.ts
export function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .finally(() => setLoading(false));
  }, [url]);
  
  return { data, loading };
}
```

#### Use React.FC Sparingly
```typescript
// ✅ Preferred (explicit typing)
export function Card({ title, children }: { title: string; children: React.ReactNode }) {
  return <div>{title}{children}</div>;
}

// ⚠️ Acceptable but not preferred
export const Card: React.FC<{ title: string }> = ({ title, children }) => {
  return <div>{title}{children}</div>;
};
```

### 4. State Management

#### Use useState for Local State
```typescript
const [isOpen, setIsOpen] = useState(false);
```

#### Use useReducer for Complex State
```typescript
const [state, dispatch] = useReducer(reducer, initialState);
```

#### Consider Zustand/Jotai for Global State
```typescript
// Avoid prop drilling, use lightweight state management
import { create } from 'zustand';

const useStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
}));
```

### 5. Data Fetching (Next.js 15 App Router)

#### Server Components - Direct Fetch
```typescript
// ✅ Fetch directly in Server Components
export default async function Posts() {
  const posts = await fetch('https://api.example.com/posts').then(r => r.json());
  return <PostList posts={posts} />;
}
```

#### Client Components - Use SWR or React Query
```typescript
'use client';

import useSWR from 'swr';

export function Posts() {
  const { data, error, isLoading } = useSWR('/api/posts', fetcher);
  if (isLoading) return <div>Loading...</div>;
  return <PostList posts={data} />;
}
```

### 6. Styling with Tailwind CSS

#### Use Tailwind Utility Classes
```typescript
// ✅ Preferred
<button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
  Click me
</button>
```

#### Extract Complex Styles to Components
```typescript
// ✅ For repeated patterns, create components
export function PrimaryButton({ children, ...props }: ButtonProps) {
  return (
    <button 
      className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
      {...props}
    >
      {children}
    </button>
  );
}
```

#### Use CSS Variables for Theming
```css
/* globals.css */
:root {
  --color-primary: #3b82f6;
  --color-secondary: #64748b;
}
```

### 7. Performance Optimization

#### Use React.memo Wisely
```typescript
// ✅ Only for expensive components that re-render often
export const ExpensiveComponent = React.memo(({ data }: Props) => {
  // expensive rendering logic
});
```

#### Lazy Load Components
```typescript
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('./heavy-component'), {
  loading: () => <p>Loading...</p>,
});
```

#### Use Suspense Boundaries
```typescript
import { Suspense } from 'react';

export default function Page() {
  return (
    <Suspense fallback={<Loading />}>
      <AsyncComponent />
    </Suspense>
  );
}
```

### 8. Error Handling

#### Use Error Boundaries
```typescript
// error.tsx in Next.js App Router
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

### 9. Code Organization

#### Folder Structure
```
src/
├── app/                    # Next.js App Router pages
│   ├── (auth)/            # Route groups
│   │   ├── login/
│   │   └── signup/
│   ├── dashboard/
│   │   ├── page.tsx
│   │   └── layout.tsx
│   ├── layout.tsx
│   └── page.tsx
├── components/            # Shared components
│   ├── ui/               # UI primitives (buttons, inputs)
│   ├── forms/            # Form components
│   └── layout/           # Layout components
├── hooks/                # Custom hooks
├── lib/                  # Utilities and helpers
│   ├── utils.ts
│   └── api-client.ts
├── types/                # TypeScript types
│   └── user.types.ts
└── constants/            # Constants and configs
    └── api-endpoints.constants.ts
```

### 10. Testing Considerations

#### Write Testable Components
```typescript
// ✅ Pure, testable component
export function formatUserName(firstName: string, lastName: string): string {
  return `${firstName} ${lastName}`;
}

export function UserGreeting({ user }: { user: User }) {
  return <h1>Hello, {formatUserName(user.firstName, user.lastName)}</h1>;
}
```

## Code Quality Rules

### 1. Always Use TypeScript
- No `any` types unless absolutely necessary
- Use proper type inference
- Define interfaces for all props and data structures

### 2. Functional Components Only
- No class components
- Use hooks for lifecycle and state

### 3. Destructure Props
```typescript
// ✅ Preferred
export function Card({ title, description }: CardProps) { }

// ❌ Avoid
export function Card(props: CardProps) {
  return <div>{props.title}</div>;
}
```

### 4. Use Const Assertions
```typescript
const ROUTES = {
  HOME: '/',
  DASHBOARD: '/dashboard',
} as const;
```

### 5. Avoid Inline Functions in JSX (for performance-critical components)
```typescript
// ✅ Preferred
const handleClick = useCallback(() => {
  // logic
}, [dependencies]);

return <button onClick={handleClick}>Click</button>;

// ⚠️ Acceptable for simple cases
return <button onClick={() => console.log('clicked')}>Click</button>;
```

### 6. Use Meaningful Variable Names
```typescript
// ✅ Good
const isUserAuthenticated = checkAuth();
const filteredActiveUsers = users.filter(u => u.isActive);

// ❌ Bad
const flag = checkAuth();
const arr = users.filter(u => u.isActive);
```

## Next.js Specific Rules

### 1. Use App Router Conventions
- Place pages in `app/` directory
- Use `layout.tsx` for shared layouts
- Use `loading.tsx` for loading states
- Use `error.tsx` for error handling

### 2. API Routes
```typescript
// app/api/users/route.ts
export async function GET(request: Request) {
  const users = await fetchUsers();
  return Response.json(users);
}
```

### 3. Metadata API
```typescript
// Static metadata
export const metadata: Metadata = {
  title: 'My Page',
  description: 'Page description',
};

// Dynamic metadata
export async function generateMetadata({ params }): Promise<Metadata> {
  return {
    title: `User ${params.id}`,
  };
}
```

### 4. Image Optimization
```typescript
import Image from 'next/image';

<Image
  src="/profile.jpg"
  alt="Profile"
  width={500}
  height={500}
  priority // for above-the-fold images
/>
```

## Accessibility

### 1. Semantic HTML
```typescript
// ✅ Use semantic elements
<nav>
  <ul>
    <li><a href="/">Home</a></li>
  </ul>
</nav>

// ❌ Avoid div soup
<div>
  <div>
    <div onClick={goHome}>Home</div>
  </div>
</div>
```

### 2. ARIA Labels
```typescript
<button aria-label="Close modal" onClick={onClose}>
  <X />
</button>
```

### 3. Keyboard Navigation
```typescript
<div
  role="button"
  tabIndex={0}
  onClick={handleClick}
  onKeyDown={(e) => e.key === 'Enter' && handleClick()}
>
  Click me
</div>
```

## Environment Variables

### Use Next.js Environment Variable Conventions
```typescript
// Public variables (exposed to browser)
NEXT_PUBLIC_API_URL=https://api.example.com

// Server-only variables
DATABASE_URL=postgresql://...
API_SECRET_KEY=secret
```

## Git Commit Conventions

Use conventional commits:
- `feat:` new feature
- `fix:` bug fix
- `docs:` documentation changes
- `style:` formatting, missing semicolons, etc.
- `refactor:` code restructuring
- `test:` adding tests
- `chore:` maintenance tasks

## Summary

When working on this project, AI agents should:
1. **Always use kebab-case** for file and folder names (except Next.js special files)
2. Follow **modern React patterns** (hooks, composition, Server Components)
3. Use **TypeScript strictly** with proper typing
4. Prefer **Server Components** over Client Components when possible
5. Follow **Next.js 15 App Router** conventions
6. Write **clean, readable, and maintainable** code
7. Prioritize **performance and accessibility**
8. Use **Tailwind CSS** for styling
9. Follow **functional programming** principles where applicable
10. Keep components **small, focused, and testable**
